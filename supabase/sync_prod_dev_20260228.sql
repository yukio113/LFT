-- Sync DDL for production/development Supabase parity
-- Generated on 2026-02-28
-- This script is idempotent and safe to re-run.

begin;

-- 1) posts: platform column required by app/page.tsx
alter table if exists public.posts
  add column if not exists platform text;

-- 2) profiles table + RLS/policies
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  tracker_platform text,
  tracker_handle text,
  display_name text,
  avatar_url text,
  current_rank_tier text,
  current_rank_division integer,
  max_rank_tier text,
  max_rank_division integer,
  tracker_level integer,
  tracker_rank_score integer,
  tracker_kills integer,
  tracker_damage integer,
  tracker_raw jsonb,
  age_group text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table if exists public.profiles enable row level security;

drop policy if exists "Users can read own profile" on public.profiles;
drop policy if exists "Authenticated users can read profiles" on public.profiles;
create policy "Authenticated users can read profiles"
  on public.profiles for select
  using (auth.role() = 'authenticated');

drop policy if exists "Users can upsert own profile" on public.profiles;
create policy "Users can upsert own profile"
  on public.profiles for insert
  with check (auth.uid() = user_id);

drop policy if exists "Users can update own profile" on public.profiles;
create policy "Users can update own profile"
  on public.profiles for update
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- 3) application_results table + constraints/indexes + RLS/policies
create table if not exists public.application_results (
  id bigint generated by default as identity primary key,
  post_id bigint not null,
  post_title text not null,
  vc_type text,
  recruiter_user_id uuid not null references auth.users(id) on delete cascade,
  applicant_user_id uuid not null references auth.users(id) on delete cascade,
  status text not null,
  ea_account_name text,
  discord_invite_link text,
  message text,
  created_at timestamptz not null default now()
);

alter table if exists public.application_results
  add column if not exists vc_type text;

-- Ensure required constraints exist even if table was created partially in one environment.
do $$
begin
  if not exists (
    select 1
    from pg_constraint c
    join pg_class t on t.oid = c.conrelid
    join pg_namespace n on n.oid = t.relnamespace
    where n.nspname = 'public'
      and t.relname = 'application_results'
      and c.conname = 'application_results_status_check'
  ) then
    alter table public.application_results
      add constraint application_results_status_check
      check (status in ('selected', 'rejected'));
  end if;

  if not exists (
    select 1
    from pg_constraint c
    join pg_class t on t.oid = c.conrelid
    join pg_namespace n on n.oid = t.relnamespace
    where n.nspname = 'public'
      and t.relname = 'application_results'
      and c.conname = 'application_results_post_id_applicant_user_id_key'
  ) then
    alter table public.application_results
      add constraint application_results_post_id_applicant_user_id_key
      unique (post_id, applicant_user_id);
  end if;
end $$;

create index if not exists application_results_applicant_idx
  on public.application_results (applicant_user_id, created_at desc);

create index if not exists application_results_recruiter_idx
  on public.application_results (recruiter_user_id, created_at desc);

alter table if exists public.application_results enable row level security;

drop policy if exists "Applicants can read own results" on public.application_results;
create policy "Applicants can read own results"
  on public.application_results for select
  using (auth.uid() = applicant_user_id);

drop policy if exists "Recruiters can read own sent results" on public.application_results;
create policy "Recruiters can read own sent results"
  on public.application_results for select
  using (auth.uid() = recruiter_user_id);

drop policy if exists "Recruiters can insert results for own posts" on public.application_results;
create policy "Recruiters can insert results for own posts"
  on public.application_results for insert
  with check (
    auth.uid() = recruiter_user_id
    and exists (
      select 1
      from public.posts p
      where p.id = application_results.post_id
        and p.user_id::text = auth.uid()::text
    )
    and exists (
      select 1
      from public.applications a
      where a.post_id = application_results.post_id
        and a.applicant_user_id::text = application_results.applicant_user_id::text
    )
  );

commit;
